
#ifndef __GateWayTaskQueue_H
#define __GateWayTaskQueue_H

#ifdef __cplusplus
extern "C" {
#endif 
    
 /*
1、主站往队列服务发送任务，队列服务里面进行队列排队
2、队列服务检测到前置机关于这个集中器空闲了，发送任务给前置机，
3、前置机检测集中器状态是否繁忙，若空闲且在线则接受任务并发送给集中器，
4、等待集中器回复已收到，标识集中器进入空闲状态，通知队列服务集中器空闲，
5、收到集中器回复任务执行结果，转发结果给队列服务，
6、队列服务转发结果给主站





1：前置机下发任务给集中器 
2：集中器把任务推入到任务队列当中 集中器收到应答  如果集中器表库中没有此ID 应答错误 
3：任务队列程序 查找时隙表库 把时隙表库总对应ID的任务数++ 
4：时隙任务 周期查找 时隙表库 如果此时有任务需要执行而且当前无线没有被占用  就调用
   无线任务 ，在无线任务中 根据ID查找任务队列 取出任务信息 以及任务号 任务内容

5：如果无线任务执行成功，则设置正在执行的任务号  ，等待任务数-1 
5、无线任务下发成功，等待任务数-1，执行任务号=当前任务，超时计数=2，
6：如果无线任务不成功，则CommNum++  TaskNum-- ，TaskLoop++ ，
  */
  
    typedef struct
    { 
      uint8_t   MeterID[6]    ;//表地址
      uint8_t   CommNum       ;//通信成功次数 
      uint8_t   TaskNum       ;//待执行任务数量,仅当TaskID==0时再处理任务，发送成功时-1      
      uint16_t  TaskID        ;//正在执行的任务序列号，0表示没有任务在执行，发送成功时=发送任务的序列号，接收成功时根据该序列号读取任务并组帧发送给前置机
      uint8_t   Timeout       ;//多少轮后超时，任务发送成功后设置为改任务的超时次数，每轮检测-1，如果==0则给前置机回复失败
    }Str_MeterLib_PARM        ;// 表库要素
  
  
  
  
  
  
  
  
  
  
  
  
  


#ifdef __cplusplus
}
#endif
#endif
